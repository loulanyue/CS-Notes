

# 进程和线程的由来

    串行			初期的计算机智能串行执行任务，并且需要长时间等待用户输入
    批处理    预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行
    进程      进程独占内存空间，保存各自运行状态，相互间不干扰且可以相互切换，为并发处理任务提供了可能
    线程      共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务得以并发执行

# 进程和线程的区别

    进程是资源分配的最小单位，线程是CPU调度的最小单位
    1.所有与进程相关的资源，都被记录在PCB中
    2.进程是抢占处理机的调度单位；线程属于某个进程，共享其资源
    3.线程只由堆栈寄存器、程序计数器和TCB组成

    总结

    1.线程不能看做独立应用，而进程可看做独立应用
    2.进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
    3.线程没有独立的地址空间，多进程的程序笔多线程程序健壮
    4.进程的切换比线程的切换开销大

# Java进程和线程的关系

    1.Java对操作系统提供的功能进行封装，包括进程和线程
    2.运行一个程序产生一个进程，进程包含至少一个线程
    3.每个进程对应一个JVM实例，多个线程共享JVM里的堆
    4.Java采用单线程编程模型，程序会自动创建主线程
    5.主线程可以创建子线程，原则上要后于子线程完成执行

# hg.openjdk.java.net/jdk8u/jdk/file

# Thread中的start和run方法的区别

    start()->JVM_StartThread->thread_entry->run()
    1.调用start()方法会创建一个新的子线程并启动
    2.run()方法只是Thread的一个普通方法的调用

# Thread和Runnable是什么关系

    1.Thread是实现了Runnable接口的类，使得run支持多线程
    2.因类的单一继承原则，推荐多使用Runnable接口

# 如何给run()方法传参

    实现的方式主要有三种
    1.构造函数传参
    2.成员变量传参
    3.回调函数传参

# 如何实现处理线程的返回值

    实现的方式主要有三种
    1.主线程等待法
    2.使用Thread类的join()阻塞当前线程以等待子线程处理完毕
    3.通过Callable接口实现：通过FutrueTask Or 线程池获取

# 线程的状态

    六个状态

    1.新建(New)：创建后尚未启动的线程的状态
    2.运行(Runnable)：包含Running和Ready
    3.无限期等待(Waiting)：不会被分配CPU执行时间，需要显式被唤醒
    4.限期等待(Timed Waiting)：在一定时间后会由系统自动唤醒
    5.阻塞(Blocked)：等待获取排它锁
    6.结束(Terminated)：已终止线程的状态，线程已经结束执行

# 限期等待：

    Thread.sleep()方法
    设置了Timeout参数的Object.wait()方法
    设置了Timeout参数的Thread.join()方法
    LockSupport.parkNanos()方法
    LockSupport.parkUntil()方法

# sleep和wait的区别

    基本的差别

    1.sleep是Thread类的方法，wait是Object类中定义的方法
    2.sleep()方法可以在任何地方使用
    3.wait()方法只能在synchronized方法或synchronized块中使用

    最主要的本质区别

    1.Thread.sleep只会让出CPU，不会导致锁行为的改变
    2.Object.wait不仅让出CPU，还会释放已经占有的同步资源锁


# 两个概念

    锁池EntryList
    等待池WaitSet

    锁池

    假设线程A已经拥有了某个对象（不是类）的锁，而其它线程B、C想调用这个对象的某个synchronized方法（或者块），由于B、C线程在进入对象的synchronized方法（或者块）之前必须先获得该对象锁的拥有权，而恰巧该对象的锁目前正被线程A所占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池

    等待池

    假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会去竞争改对象的锁

# notify和notifyAll的区别

    notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会
    notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会

# yield

    概念
    当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU的暗示，但是线程调度器可能会忽略这个提示。

# 如何中断线程

    已经被抛弃的方法
    通过调用stop()方法停止线程
    通过调用suspend()和resume()方法
    目前使用的方法
    调用interrupt()，通知线程应该中断了
    1.如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常
    2.如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。
