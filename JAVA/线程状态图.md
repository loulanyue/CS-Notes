## 线程变化的状态转换图如下：
### 1.新建状态(New)：新创建了一个线程对象。

### 2、就绪状态(Runnable)：线程对象创建后，其它线程调用了该对象的start()方法。该状态的线程位于可执行线程池中，变得可执行，等待获取CPU的使用权。

### 3、执行状态(Running)：就绪状态的线程获取了CPU。执行程序代码。

### 4、堵塞状态(Blocked)：堵塞状态是线程由于某种原因放弃CPU使用权。临时停止执行。直到线程进入就绪状态，才有机会转到执行状态。

## 堵塞的情况分三种：

### 1、等待堵塞：执行的线程执行wait()方法，JVM会把该线程放入等待池中。

### 2、同步堵塞：执行的线程在获取对象的同步锁时，若该同步锁被别的线程占用。则JVM会把该线程放入锁池中。

### 3、其它堵塞：执行的线程执行sleep()或join()方法，或者发出了I/O请求时。JVM会把该线程置为堵塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完成时。线程又一次转入就绪状态。

### 4、死亡状态(Dead)：线程运行完了或者因异常退出了run()方法，该线程结束生命周期。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190714202216422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdWxhbnl1ZV8=,size_16,color_FFFFFF,t_70)
### 说明：
#### 1、线程的实现有两种方式，一是继承Thread类，二是实现Runnable接口，但无论如何，当我们new了这个对象后。线程就进入了初始状态；
#### 2、当该对象调用了start()方法，就进入可执行状态；
#### 3、进入可执行状态后，当该对象被操作系统选中。获得CPU时间片就会进入执行状态；
#### 4、进入执行状态后情况就比較复杂了
	
	1.run()方法或main()方法结束后，线程就进入终止状态；
	2、当线程调用了自身的sleep()方法或其它线程的join()方法，就会进入堵塞状态（该状态既停止当前线程，但并不释放所占有的资源）。当sleep()结束或join()结束后。该线程进入可执行状态，继续等待OS分配时间片；
	3、线程调用了yield()方法，意思是放弃当前获得的CPU时间片，回到可执行状态，这时与其它进程处于同等竞争状态，OS有可能会接着又让这个进程进入执行状态。
	4、当线程刚进入可执行状态（注意，还没执行），发现将要调用的资源被synchroniza（同步），获取不到锁标记。将会马上进入锁池状态，等待获取锁标记（这时的锁池里或许已经有了其它线程在等待获取锁标记，这时它们处于队列状态，既先到先得），一旦线程获得锁标记后，就转入可执行状态。等待OS分配CPU时间片。
	5、当线程调用wait()方法后会进入等待队列（进入这个状态会释放所占有的全部资源，与堵塞状态不同）。进入这个状态后。是不能自己主动唤醒的，必须依靠其它线程调用notify()或notifyAll()方法才干被唤醒（因为notify()仅仅是唤醒一个线程，但我们由不能确定详细唤醒的是哪一个线程。或许我们须要唤醒的线程不可以被唤醒，因此在实际使用时，一般都用notifyAll()方法，唤醒有所线程），线程被唤醒后会进入锁池。等待获取锁标记。
