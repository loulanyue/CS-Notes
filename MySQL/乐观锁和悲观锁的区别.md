## 悲观锁（Pessimistic Lock）
>##### 悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作；通常所说的“一锁二查三更新”即指的是使用悲观锁。
## 乐观锁（Optimistic Lock）
>##### 乐观锁的特点先进行业务操作，不到万不得已不去拿锁；即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好；乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：

>   1. SELECT data AS old_data, version AS old_version FROM …;
	2. 根据获取的数据进行业务操作，得到new_data和new_version
	3. UPDATE SET data = new_data, version = new_version WHERE version = old_version
	if (updated row > 0) {
	    // 乐观锁获取成功，操作完成
	} else {
	    // 乐观锁获取失败，回滚并重试
	}
	乐观锁是否在事务中其实都是无所谓的
	
>##### 其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放，因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改；如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。
